#!/usr/bin/python

# Written in Python for version 2.7.5+
# Developed and tested with Python 2.7.5
# Should work with Python 3+
#
# Short note on Pythonic OOP:
# By design, Python does not support Private methods.
# However, any method prepended with an underscore 
# indicates an internal method. The interpreter does not
# react to this, but is in place so that internal methods are not
# accidentally accessed, as one would have to break convention of 
# using an underscored method from outside the class.
#
# Microprocessor Architecture Coursework 2: Cache Simulator
# Based on a simple Von Neumann Architecture
# using CPU instructions located by default
# in trace file "trace.txt"
# Generates Log File "cache.log" provided by Python logging library
#
# BASIC OPERATION:
# Two thread based classes: 'CacheSim' and 'CpuSim'
# CpuSim reads the tracefile into memory and sends them to global FIFO 
# Queue object 'instructionQueue'.
#
# CacheSim pops the first item off the queue before simulating the 
# function of a cache, as defined by the input parameters.
# This process will be repeated until the Queue is empty, at which point
# the program will exit.
#
# LOG FILE:
# The log file will by default be set to INFO verbosity. However, DEBUG 
# messages may be displayed also by changing the logging value to:
# 'level = logging.DEBUG'.
#
# By default, each run of the simulator will clear the logfile and 
# overwrite it. If this is not desired, you must change the filemode
# from 'W' (write) to 'R' (read). 
#
# Each log entry it prepended with the level (i.e. INFO, DEBUG, WARNING or ERROR)
# followed by the 'branch'. For this project, all branches are 'root'.
# Log entries generated by the a thread will also include the thread name,
# either CPUSIM or CACHESIM for the respective threads.
#
# After this will be the message. A cache HIT will be signified by 'HIT!', 
# and ANY cache misses signified with 'MISS'.
# In debug mode, addresses may be represented in their hex form, 
# as this is how they have been read in. 
# Most logging outputs will refer to binary information in the 
# integer form, including index and tag values.
#
# If a value has not been assigned, the pythonic type 'None' will be
# allocated as there is nothing to assign. Please consider that in a real
# system, this may just be an invalid or garbled value containted in
# memory that has no functional value.

# Gregory Fudge
# Student ID: B126046
# EESE Department
# Loughborough University
# G.Fudge-11@student.lboro.ac.uk

# Import libraries
import math
import logging
import Queue
import threading
import time

# Bit Constants
DIRTY	= 0
VALID	= 1
TAG 	= 2
LINE	= 3

# Instruction FIFO Queue data structure
instructionQueue = Queue.Queue(maxsize=1)

# Return data queue
# Has nothing to do with architecture (As it is unified bus, Von Neumann)
# Used only as return pipeline for data when data is needed
dataBus = Queue.Queue()

class cacheSim(threading.Thread):
	# Constructor Method
	def __init__( self ):
		# Init base class (Thread name: CACHESIM)
		threading.Thread.__init__(self, name='CACHESIM')
		# Class Properties
		# Parameters for Cache
		self.memorySize = 2**30
		self.cacheSize = 2**20
		self.cacheWays = 2
		self.wordWidth = 32
		self.cacheLineLength = 8
		self.dataLength = self.wordWidth
		# Generated Widths based on Cache parameters
		self.indexWidth = int(math.log(((self.cacheSize/(self.cacheWays))/self.cacheLineLength),2))
		#self.tagWidth = int(math.log(self.memorySize, 2) - self.indexWidth)
		self.offsetWidth = int(math.log(self.cacheLineLength, 2))
		self.tagWidth = self.wordWidth - self.indexWidth - self.offsetWidth
		self.cacheLines = int(self.cacheSize / (self.cacheLineLength))
		self.memoryLines = int(self.memorySize / (self.cacheLineLength))

		# Log the cache parameters
		logging.info('%s: Physical Memory:  \t %s bytes', self.name, self.memorySize)
		logging.info('%s: Cache Memory:     \t %s bytes', self.name, self.cacheSize)
		logging.info('%s: Cache Ways:       \t %s ', self.name, self.cacheWays)
		logging.info('%s: Cache Line Length:\t %s words', self.name, self.cacheLineLength)
		logging.info('%s: Data Length:      \t %s bits', self.name, self.dataLength)
		# Bit mapping for cpu generated addresses
		# Especially useful for parametric widths and visualising them
		logging.info( "<%-*s>" % (self.wordWidth, str(''.join(['T' for y in range(self.tagWidth)] + ['I' for y in range(self.indexWidth)] + ['O' for y in range(self.offsetWidth)] + ['X' for y in range(self.wordWidth - self.tagWidth - self.indexWidth - self.offsetWidth)]))) )

		# Generate Bitmasks
		self.offsetMask = self._generateOffsetMask()
		self.indexMask = self._generateIndexMask()
		self.tagMask = self._generateTagMask()

		# Call cache init method
		self._initCache()
		# Call memory init method
		self._initMainMemory()

	## PRIVATE METHODS

	# Init method for cache
	# Allocated a list (array-like structure) with four elements
	# VALID and DIRTY flags initialised as FALSE (Boolean)
	# Line data and tags initialised as NONETYPE (Placeholder for data)
	def _initCache(self):
		logging.info('%s: Initialising Cache of %s lines', self.name, self.cacheLines)
		# Initialise cache memory as list using list comprehensions
		# 4 by (self.cacheLines) array-like data structure 
		self.cacheMemory = [[False, False, None, [None for x in range(self.cacheLineLength)]] for y in range(self.cacheLines)]
		print "Cache len: ", len(self.cacheMemory)
		print self.cacheMemory[0]
		logging.info('%s: Cache initialised', self.name)

	def _initMainMemory(self):
		logging.info('%s: Initialising Main Memory %s lines', self.name, self.memoryLines)
		# Initialise main memory as empty list
		# using list comprehensions
		# as type NONE
		self.mainMemory = [None for y in range(self.memoryLines)]
		print "Mem len: ", len(self.mainMemory)
		logging.info('%s: Main Memory initialised', self.name)
	
	# Method takes a hexadecimal string argument (prepended with 0x)
	# and returns a binary string
	def _hex2Bin(self, s):	
		s = int(s, 16)
		return str(s) if s<=1 else bin(s>>1) + str(s&1)

	# Method takes a integer argument and returns a binary string
	def _int2Bin(self, s):	
		return str(s) if s<=1 else bin(s>>1) + str(s&1)

	# Generate Offset Mask for CPU produced addresses
	def _generateOffsetMask(self):
		binOffset = ''
		bit = self.wordWidth
		# Maximum and minimum values of bits for the offset 
		maskMax = int(self.wordWidth - (self.tagWidth + self.indexWidth))
		maskMin = int(self.wordWidth - (self.tagWidth + self.indexWidth + self.offsetWidth))
		# Count down bits from wordWidth to 0
		while (bit > 0):
			# If bit is within offset boundaries, set to '1'
			if (bit <= maskMax):
				binOffset = binOffset + "1"
			else:
			# If outside boundaries, set to '0'
				binOffset = binOffset + "0"
			bit -= 1
		logging.info('%s: Offset bitmask: %s', self.name, hex(int(binOffset, 2)))
		return hex(int(binOffset, 2))
	
	# Generate Index Mask for CPU produced addresses
	def _generateIndexMask(self):
		binIndex = ''
		bit = self.wordWidth
		# Maximum and minimum values of bits for the index
		maskMax = int(self.wordWidth - self.tagWidth)
		maskMin = int(self.wordWidth - (self.tagWidth + self.indexWidth))
		# Count down bits from wordWidth to 0
		while (bit > 0):
			# If bit is within index boundaries, set to '1'
			if (bit <= maskMax) and (bit > maskMin):
				binIndex = binIndex + "1"
			# If bit it outside index boundaries, set to '0'
			else:
				binIndex = binIndex + "0"
			bit -= 1
		logging.info('%s: Index bitmask: %s', self.name, hex(int(binIndex, 2)))
		return hex(int(binIndex, 2))

	# Generate Tag Mask for CPU produced addresses
	def _generateTagMask(self):
		binTag = ''
		bit = self.wordWidth
		# Count down bits from wordWidth to 0
		while (bit > 0):
			# If bit is within tag boundaries, set to '1'
			if (bit > (self.wordWidth - self.tagWidth)):
				binTag = binTag + "1"
			# If bit is outside index boundaries, set to '0'
			else:
				binTag = binTag + "0"
			bit -= 1
		logging.info('%s: Tag bitmask: %s', self.name, hex(int(binTag, 2)))
		return hex(int(binTag, 2))

	# Main execution routine
	# Contains majority of CACHE operations
	def _executeQueue(self):
		# Loop until there are no more instructions to execute
		while not instructionQueue.empty():
			# Fetch next queued instruction
			instruction = instructionQueue.get()
			if ( instruction == 'END' ): break
			logging.debug('%s: Executing instruction: %s', self.name, instruction)
			# Generate integer index and tag for instruction
			offset = self._generateOffset(instruction[1])
			print "Offset: ", offset
			index = self._generateIndex(instruction[1])
			tag = self._generateTag(instruction[1])
			logging.debug('%s: Tag: %s \t Index: %s \t Offset: %s \t', self.name, tag, index, offset)
			# Generate integer versions of CPU produced address, data
			memAddress = self._hex2int(instruction[1])
			# Read operation
			if ( instruction[0] == 'R' ):
				logging.debug('%s: Reading address %s', self.name, instruction[1])
				# For each cache 'way'
				for way in range(self.cacheWays):
					# Cache Hit if Valid is True and tag matches
					if ( self.getValidBit(index + way) and (self.getTag(index + way) == tag) ):
						logging.info('%s: HIT!: %s', self.name, index + way)
						print "HIT", tag, index + way
						dataBus.put(self._readFromCache(index + way, tag, offset))
						break
					# Cache Miss if Valid is True and tag does not match
					elif ( self.getValidBit(index + way) and (self.getTag(index + way) != tag) ):
						logging.info('%s: MISS: Invalid tag', self.name)
						# If dirty bit True
						if ( self.getDirtyBit(index + way) ):
							# WRITEBACK
							print "Writeback"
							self._memoryWriteback(memAddress, index + way, offset)
						# Else
						else:
							# EVICT & REWRITE FROM MAIN MEM
							print "Evict"
							self._evictCacheLine(index + way)
							self._writeToCache(index + way, tag, offset, self._readFromMemory(index, offset))
					
					elif ( not self.getValidBit(index + way) ):
						logging.info('%s: MISS: Invalid cache line', self.name)
						print "Read from MEM"
						self._writeToCache(index + way, tag, offset, self._readFromMemory(memAddress, offset))
						print self.cacheMemory[index + way][LINE] 
			# Write operation
			elif ( instruction[0] == 'W' ):
				logging.debug('%s: Writing data %s to address %s', self.name, instruction[2], instruction[1])
				if ( self.getDirtyBit(index) ):
					self._writeToCache(index, tag, offset, self._hex2int(instruction[2]))
					logging.info("%s: Writeback at %s", self.name, index + way)
					print "Writeback needed"
					
				else:
					print "No writeback needed"
					self._memoryWriteback(memAddress, index, offset)
					self._evictCacheLine(index)
					self._writeToCache(index, tag, offset, self._hex2int(instruction[2]))
					
			else:
				logging.warning('%s: Invalid instruction: %s', self.name, instruction)	
				print "Invalid Instruction"
	# Returns integer equivalent of hexadecimal input argument
	def _hex2int(self, hexa):
		return int(hexa, 0)
	
	# Generates an offset from the address and bitmask
	def _generateOffset(self, address):
		# Returns integer offset bitwise masked with offsetMask, shifted right by remaining bits
		print self.wordWidth - (self.indexWidth + self.tagWidth + self.offsetWidth)
		return int(int(address, 16) & int(self.offsetMask, 16)) >> int(self.wordWidth - (self.indexWidth + self.tagWidth + self.offsetWidth))

	# Generates an index from the address and bitmask
	def _generateIndex(self, address):
		# Returns integer index bitwise masked with indexMask, shifted right by remaining bits
		return int((int(address, 16) & int(self.indexMask, 16)) >> int(self.wordWidth - (self.indexWidth + self.tagWidth)))

	# Generates an tag from the address and bitmask
	def _generateTag(self, address):
		# Returns integer tag bitwise masked with tagMask, shifted right by remaining bits
		return int((int(address, 16) & int(self.tagMask, 16)) >> int(self.wordWidth - self.tagWidth))	
	
	# Method to read from memory
	def _readFromMemory(self, memoryLine, offset):
		logging.info('%s: Read from memory: %s', self.name, self.mainMemory[memoryLine])
		# If memory address has not been updated since init, return 'None' (Nothing to return)
		if ( self.mainMemory[memoryLine] == None ):
			print "Empty Memory"
			# Update cacheline to contain data of type 'None'
			return None
			logging.debug('%s: Attempted to read from Main Memory %s, contains None', self.name, memoryLine)
		else:
			# Return data at address in Main memory (perform memory access)
			print self.mainMemory[memoryLine]
			return self.mainMemory[memoryLine]
			logging.debug('%s: Read line %s from Main Memory', self.name, memoryLine)
		
	def _readFromCache(self, index, tag, offset):
		print "Read Cache: ", self.cacheMemory[index]
		logging.info('%s: Read from cache: %s', self.name, self.cacheMemory[index][LINE][offset])	
		return self.cacheMemory[index][LINE][offset]

	# Method to write to cache
	def _writeToCache(self, index, tag, offset, data):
		print offset, data
		print len(self.cacheMemory[index])
		# Write data to cache line
		self.cacheMemory[index][LINE][offset] = data
		# Update tag to cache line
		self.cacheMemory[index][TAG] = tag
		# Set dirty bit True
		self.cacheMemory[index][DIRTY] = True
		# Set valid bit True
		self.cacheMemory[index][VALID] = True
		logging.info('%s: Written %s to cache: %s', self.name, data, offset)

	# Method to writeback to memory
	# Writes [index][word] from cache to main memory
	def _memoryWriteback(self, memLine, index, offset):
		# Writeback data from cacheline to memory
		self.mainMemory[memLine] = self.cacheMemory[index][LINE][offset]
		# Set dirty bit to False
		self.cacheMemory[index][DIRTY] = False

	# Method to evict cache line but emptying tag, data and setting both flags False
	def _evictCacheLine(self, index):
		# Set cache line data to empty string
		self.cacheMemory[index][LINE] = [None for y in range(self.cacheLineLength)]
		# Set cache line tag to empty string
		self.cacheMemory[index][TAG] = None
		# Set dirty bit to false
		self.cacheMemory[index][DIRTY] = False
		# Set valid bit to false
		self.cacheMemory[index][VALID] = False
		logging.info('%s: Cache line %s evicted', self.name, index)

	# PUBLIC METHODS (BIN?)
	## CONSIDER REMOVING SETTER METHODS AS THESE ARE NOT USED/REQUIRED
	
	# Method to get dirty bit of cache line (GET)
	def getDirtyBit(self, cacheLine):
		return self.cacheMemory[cacheLine][DIRTY]
	
	# Method to set dirty bit of cache line (SET)
	def setDirtyBit(self, cacheLine, dirtyBit):
		self.cacheMemory[cacheLine][DIRTY] = dirtyBit
		logging.debug('%s: Set dirty bit of %s to %s', self.name, cacheLine, dirtyBit)
	
	# Method to get valid bit of cache line (GET)
	def getValidBit(self, cacheLine):
		return self.cacheMemory[cacheLine][VALID]

	# Method to set valid bit of cache line (SET)
	def setValidBit(self, cacheLine, validBit):
		self.cacheMemory[cacheLine][VALID] = validBit
		logging.debug('%s: Set valid bit of %s to %s', self.name, cacheLine, dirtyBit)

	# Method to get TAG of cache line (GET)
	def getTag(self, cacheLine):
		return self.cacheMemory[cacheLine][TAG]

	# Default method called on thread.start()
	def run(self):
		# Delay to resolve race hazard condition between cpu and cache simulators
		time.sleep(0.1)
		self._executeQueue()


# CPU Simulator class
# Generates instructions, addresses & data for basic memory operations only
# Extracts data from trace file and queues it onto global FIFO "Queue" data structure
class cpuSim(threading.Thread):
	# Constructor method
	# Opens file for reading
	def __init__(self):
		# Init thread base class
		threading.Thread.__init__(self, name='CPUSIM')
		# Open file "trace.txt", read only
		self._fileName = 'trace.txt'
		# File 'pointer' object
		self._traceFile = open(self._fileName, 'r')
		logging.info('%s: Trace file %s open', self.name, self._fileName)

	# PRIVATE METHODS
	# Method to read trace file and place instructions onto
	# FIFO queue for cache
	def _generateTraceQueue(self):
		# For each line in trace file
		for line in self._traceFile.readlines():
			# Delimit whitespace and put list on queue
			instructionQueue.put(line.split())
			logging.debug('%s: Writing %s to bus', self.name, line.strip())
		logging.info('%s: File: %s has been read', self.name, self._fileName)
		instructionQueue.put('END')

	# Called on Thread.Start(), immediately runs self._generateTraceQueue() method	
	def run(self):
		logging.info('%s: CPU Queue Start', self.name)
		self._generateTraceQueue()
		logging.info('%s: CPU Queue Finished', self.name)

def main():
	# Overwrite log file 
	logging.basicConfig(filename='cache.log', filemode='w', level=logging.DEBUG)
	# Instansiate CPU Simulator Thread
	logging.info('Initialising Threads')
	CpuSimulator = cpuSim()	
	CacheSimulator = cacheSim()
	# Start Threads
	logging.info('Starting Threads %s %s', CpuSimulator.name, CacheSimulator.name)	
	CpuSimulator.start()
	CacheSimulator.start()
	logging.info('Threads %s %s running...', CpuSimulator.name, CacheSimulator.name)
	
# Goto main() function	
if __name__== "__main__":
	main()
